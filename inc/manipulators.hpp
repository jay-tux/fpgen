#ifndef _FPGEN_MANIP
#define _FPGEN_MANIP

#include "generator.hpp"
#include "type_traits.hpp"
#include <array>
#include <type_traits>

/**
 *  \brief The namespace containing all of fpgen's code.
 */
namespace fpgen {
/**
 *  \brief Maps a function over a generator.
 *
 *  Creates a new generator whose values are the transformed values generated by
 * applying the given mapping function on each value in the original generator.
 * Using the provided generator after calling fpgen::map is undefined behaviour.
 *
 *  \tparam TIn The type contained in the provided generator.
 *  \tparam Fun The function signature of the mapping function.
 *  \tparam TOut The output type. This type is deduced from the `Fun` type
 * parameter.
 *  \param[in,out] gen The generator to map over. Will be in unusable state
 * afterwards.
 *  \param[in] func The function to map with.
 *  \returns A new generator whose contained type is the return type of the
 * mapping function.
 */
template <typename TIn, typename Fun,
          typename TOut = type::output_type<Fun, TIn>,
          typename _ = type::is_function_to<Fun, TOut, TIn>>
auto map(generator<TIn> gen, Fun func)
    -> generator<typename std::invoke_result<Fun, TIn>::type> {
  while (gen) {
    co_yield func(gen());
  }
  co_return;
}

/**
 *  \brief Combines two generators into a single generator.
 *
 *  The result is a tuple of values, one taken from each generator. Once one of
 * the generators runs out of values, the newly generator stops as well. Using
 * either generator after calling this function is undefined behaviour.
 *
 *  \tparam T1 The type contained in the first generator.
 *  \tparam T2 The type contained in the second generator.
 *  \param[in, out] gen1 The first generator to use.
 *  \param[in, out] gen2 The second generator to use.
 *  \returns A new generator containing tuples of values from both generators.
 */
template <typename T1, typename T2>
generator<std::tuple<T1, T2>> zip(generator<T1> gen1, generator<T2> gen2) {
  while (gen1 && gen2) {
    co_yield {gen1(), gen2()};
  }
  co_return;
}

/**
 *  \brief Filters a generator, keeping only values matching a predicate.
 *
 *  The result is a generator with as much or possibly fewer elements. Each
 * element is an element in the original generator. Elements not matching the
 * predicate are removed.
 *
 *  \tparam T The type contained in the generator.
 *  \tparam Pred The function type of the predicate function. Should return a
 * bool.
 *  \param[in,out] gen The generator containing the original values.
 *  \param[in] p The predicate.
 *  \returns A new generator which yields all values in the original generator
 * except those not matching the predicate.
 */
template <typename T, typename Pred, typename _ = type::is_predicate<Pred, T>>
generator<T> filter(generator<T> gen, Pred p) {
  while (gen) {
    T val(gen());
    if (p(val))
      co_yield val;
  }
  co_return;
}

/**
 *  \brief Ignores the first n elements from a generator.
 *
 *  Extracts the first `count` elements from the generator and throws those
 * away. All subsequent elements in the generator are passed through as normal.
 * If there aren't enough elements in the original generator, an empty generator
 * is returned.
 *
 *  \tparam T The type contained in the generator.
 *  \param[in,out] gen The generator to drop from.
 *  \param[in] count The amount of elements to ignore.
 *  \returns A new generator yielding all values except the first n.
 */
template <typename T> generator<T> drop(generator<T> gen, size_t count) {
  for (size_t i = 0; i < count && gen; i++) {
    gen();
  }

  while (gen) {
    co_yield gen();
  }
  co_return;
}

/**
 *  \brief Yields the first n elements from a generator.
 *
 *  Extracts and yields exactly `count` elements (or less if the generator
 * doesn't contain that much values). The iteration is then stopped and no
 * further elements will be generated. If generation has side effects, the side
 * effects of elements after the first n will not be observable.
 *
 *  \tparam T The type contained in the generator.
 *  \param[in,out] gen The generator to take elements from.
 *  \param[in] count The amount of elements to yield.
 *  \returns A new generator yielding only the first n values.
 */
template <typename T> generator<T> take(generator<T> gen, size_t count) {
  for (size_t i = 0; i < count && gen; i++) {
    co_yield gen();
  }
  co_return;
}

/**
 *  \brief Drops elements while they satisfy a certain predicate.
 *
 *  Iterates over the elements in the generator and drops them until it
 * encounters a value not satisfying the predicate (`!p(value)` is true). Then
 * it starts yielding each remaining value in the generator. To remove all
 * values satisfying `p`, use `fpgen::filter(gen, [&p](auto v) { return !p(v);
 * });`.
 *
 *  \tparam T The type contained in the generator.
 *  \tparam Pred The type of the predicate (should be a T -> bool function).
 *  \param gen The generator to drop elements from.
 *  \param p The predicate.
 *  \returns A new generator where the first element is guaranteed to not
 * satisfy `p`.
 */
template <typename T, typename Pred, typename _ = type::is_predicate<Pred, T>>
generator<T> drop_while(generator<T> gen, Pred p) {
  while (gen) {
    T temp = gen();
    if (!p(temp)) {
      co_yield temp;
      break;
    }
  }

  while (gen) {
    co_yield gen();
  }
  co_return;
}

/**
 *  \brief Yields elements while they satisfy a certain predicate.
 *
 *  Iterates over the elements in the generator and yields them until it
 * encounters a value not satisfying the predicate (`!p(value)`). Then it stops
 * generating (any side effects from the subsequent elements won't be
 * observable). To obtain a generator with all elements satisfying `p`, use
 * `fpgen::filter(gen, p);` instead.
 *
 *  \tparam T The type contained in the generator.
 *  \tparam Pred The type of the predicate (should be a T -> bool function).
 *  \param gen The generator to take elements from.
 *  \param p The predicate.
 *  \returns A new generator where all elements are guaranteed to satisfy the
 * predicate and were generated before any element which didn't satisfy the
 * predicate.
 */
template <typename T, typename Pred, typename _ = type::is_predicate<Pred, T>>
generator<T> take_while(generator<T> gen, Pred p) {
  while (gen) {
    T val = gen();
    if (!p(val)) {
      break;
    }
    co_yield val;
  }
  co_return;
}
} // namespace fpgen

#endif
